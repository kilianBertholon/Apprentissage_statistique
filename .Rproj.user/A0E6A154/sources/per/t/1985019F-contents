---
title: "Projet_AS"
author: "kilian_ber"
date: "2023-11-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Librairies utilisées

```{r}
library(readODS)
```

Ouverture des des données

```{r cars}
data <- read_ods("data/data_bmx.ods")
data <- data[,-1]
```

Dans notre cas, nous allons chercher à répondre à plusieurs intérrogations qui peuvent se poser quand à l'utilisation de notre jeu de données :

1)  La position sur la grille de départ induit-elle un avantage ?

<!-- -->

a)  Existe-t-il des positions qui semble favoriser le coureur
b)  Ces positions favorisent le coureur sur l'ensemble des manches

<!-- -->

2)  Peut-on prédire le classement final assez tot dans la course ?

On va donc chercher à répondre à la question 1

# La position sur la grille de départ induit-elle un avantage ?

depart_arrivee\$Position_Start \<- as.numeric(depart_arrivee\$Position_Start)

depart_arrivee\$Classement_final \<- as.numeric(depart_arrivee\$Classement_final)

depart_arrivee\$Position_Start \<- as.factor(depart_arrivee\$Position_Start)

depart_arrivee\$Classement_final \<- factor(depart_arrivee\$Classement_final, levels = niveaux_ordre)

depart_arrivee\$Position_Start \<- as.numeric(depart_arrivee\$Position_Start)

depart_arrivee\$Classement_final \<- as.numeric(depart_arrivee\$Classement_final)

depart_arrivee\$Position_Start \<- as.factor(depart_arrivee\$Position_Start)

depart_arrivee\$Classement_final \<- factor(depart_arrivee\$Classement_final, levels = niveaux_ordre)

```{r}
library(dplyr)

data$Position_Start[data$Position_Start == -1] <- NA
# Sélectionner les lignes sans NA dans la colonne spécifiée
data <- data[complete.cases(data$Position_Start) & !grepl("DNS|DNF", data$Temps_Final), ]
data_final <- data |> filter(Manche == 'Demi-final' | 
                               Manche == 'Final' |
                               Manche == 'Quart-final')
depart_arrivee <- data[c("Position_Start", "Classement_final")]
data_final <- data_final[c("Position_Start", "Classement_final")]

niveaux_ordre <- as.character(1:8)


depart_arrivee$Position_Start <- as.numeric(depart_arrivee$Position_Start)
depart_arrivee$Classement_final <- as.numeric(depart_arrivee$Classement_final)
depart_arrivee$Position_Start <- as.factor(depart_arrivee$Position_Start)
depart_arrivee$Classement_final <- factor(depart_arrivee$Classement_final, levels = niveaux_ordre)

data_final$Position_Start <- as.numeric(data_final$Position_Start)
data_final$Classement_final <- as.numeric(data_final$Classement_final)
data_final$Position_Start <- as.factor(data_final$Position_Start)
data_final$Classement_final <- factor(data_final$Classement_final, levels = niveaux_ordre)



```

Data contient ici seulement les individus dont on connait le numero

##### Pourcetage apparitions toutes courses

```{r}
# Tableau de contingence
tableau_contingence <- table(depart_arrivee$Position_Start, depart_arrivee$Classement_final)

# Calculer les pourcentages par ligne
pourcentages <- prop.table(tableau_contingence, margin = 1) * 100

pourcentages <- round(pourcentages, 2)


```

##### Pourcetage apparitions final/demi et quart courses

```{r}
tableau_contingence2 <- table(data_final$Position_Start, data_final$Classement_final)

# Calculer les pourcentages par ligne
pourcentages2 <- prop.table(tableau_contingence2, margin = 1) * 100

pourcentages2 <- round(pourcentages2, 2)
```

```{r}
difference <- pourcentages2 - pourcentages
```

A partir de la on peut ddonc réfléchir quant à l'utilisation des différents modèles que l'on connait pour essayer de résoudre notre problème ?

-   Régression linéaire==\> Semble peut adapté ( données catégorielles )

-   Régression logistique ==\> Semble okay

-   Boosting ==\> Oui

    -   Boosting classique

    -   Boosting catboost

-   Foret aléatoire

-   Lasso / Ridge/ElasticNets

**L'ensemble sera bien sur valider par validation croisée**

## Régression logisitique

### Cross-validation avec pourcentage défini

```{r}
# Charger les packages
library(tidymodels)
library(dotwhisker)  # for visualizing regression results
library(ordinal)

data[, c("Classement_final", "Position_Start", "Rang_T1", "Rang_T2", "Rang_T3")] <- lapply(data[, c("Classement_final", "Position_Start", "Rang_T1", "Rang_T2", "Rang_T3")], as.numeric)

data[, c("Classement_final", "Position_Start", "Rang_T1", "Rang_T2", "Rang_T3")] <- lapply(data[, c("Classement_final", "Position_Start", "Rang_T1", "Rang_T2", "Rang_T3")], function(x) factor(x, levels = 1:8, ordered = TRUE))


# Charger les données (remplacez "votre_dataset.csv" par le nom de votre fichier de données)

# Spécifier les colonnes prédictives et la colonne de la variable dépendante
predictors <- c("Position_Start", "Rang_T1", "Rang_T2", "Rang_T3", "Rang_T4")  # Remplacez par vos noms de variables prédictives
response <- "Classement_final"  # Remplacez par le nom de votre variable dépendante

# # Diviser les données en ensembles d'entraînement et de test
set.seed(123)  # Pour la reproductibilité
split <- initial_split(data, prop = 0.7, strata = response)
train_data <- training(split)
test_data <- testing(split)

# Prétraitement des données
# (Cela dépendra de la nature de vos données et des transformations nécessaires)
preprocess <- recipe(formula = as.formula(paste(response, "~", paste(predictors, collapse = "+"))), data = train_data) 

# Définir le modèle de régression logistique
logistic_model <- logistic_reg(penalty = tune(), mixture = tune()) %>%
  set_engine("glmnet")  

# Créer le workflow avec les étapes de prétraitement et le modèle
workflow <- workflow() %>%
  add_recipe(preprocess) %>%
  add_model(logistic_model)

# Entraîner le modèle
trained_model <- fit(workflow, data = train_data)

# Faire des prédictions sur l'ensemble de test
predictions <- predict(trained_model, new_data = test_data)


```
