depart_arrivee$Classement_final <- as.factor(depart_arrivee$Classement_final, levels = niveaux_ordre)
library(dplyr)
data$Position_Start[data$Position_Start == -1] <- NA
# Sélectionner les lignes sans NA dans la colonne spécifiée
data <- data[complete.cases(data$Position_Start) & !grepl("DNS|DNF", data$Temps_Final), ]
depart_arrivee <- data[c("Position_Start", "Classement_final")]
niveaux_ordre <- as.character(1:8)
depart_arrivee$Position_Start <- as.numeric(depart_arrivee$Position_Start)
depart_arrivee$Classement_final <- as.numeric(depart_arrivee$Classement_final)
depart_arrivee$Position_Start <- as.factor(depart_arrivee$Position_Start)
depart_arrivee$Classement_final <- factor(depart_arrivee$Classement_final, levels = niveaux_ordre)
# Tableau de contingence
tableau_contingence <- table(depart_arrivee$Position_Start, depart_arrivee$Classement_final)
# Calculer les pourcentages par ligne
pourcentages <- prop.table(tableau_contingence, margin = 1) * 100
# Afficher le tableau
print(pourcentages)
pourcentages <- data.frame(pourcentages)
View(pourcentages)
pourcentages
# Tableau de contingence
tableau_contingence <- table(depart_arrivee$Position_Start, depart_arrivee$Classement_final)
# Calculer les pourcentages par ligne
pourcentages <- prop.table(tableau_contingence, margin = 1) * 100
pourcentages
# Tableau de contingence
tableau_contingence <- table(depart_arrivee$Position_Start, depart_arrivee$Classement_final)
# Calculer les pourcentages par ligne
pourcentages <- prop.table(tableau_contingence, margin = 1) * 100
pourcentages
# Tableau de contingence
tableau_contingence <- table(depart_arrivee$Position_Start, depart_arrivee$Classement_final)
# Calculer les pourcentages par ligne
pourcentages <- prop.table(tableau_contingence, margin = 1) * 100
pourcentages <- round(pourcentage, 2)
# Tableau de contingence
tableau_contingence <- table(depart_arrivee$Position_Start, depart_arrivee$Classement_final)
# Calculer les pourcentages par ligne
pourcentages <- prop.table(tableau_contingence, margin = 1) * 100
pourcentages <- round(pourcentages, 2)
pourcentages
14639/8
data_final <- data |> filter(Manche == 'Demi-final' |
Manche == 'Final' |
Manche == 'Quart-final')
data_final <- data_final[c("Position_Start", "Classement_final")]
library(dplyr)
data$Position_Start[data$Position_Start == -1] <- NA
# Sélectionner les lignes sans NA dans la colonne spécifiée
data <- data[complete.cases(data$Position_Start) & !grepl("DNS|DNF", data$Temps_Final), ]
data_final <- data |> filter(Manche == 'Demi-final' |
Manche == 'Final' |
Manche == 'Quart-final')
depart_arrivee <- data[c("Position_Start", "Classement_final")]
data_final <- data_final[c("Position_Start", "Classement_final")]
niveaux_ordre <- as.character(1:8)
depart_arrivee$Position_Start <- as.numeric(depart_arrivee$Position_Start)
depart_arrivee$Classement_final <- as.numeric(depart_arrivee$Classement_final)
depart_arrivee$Position_Start <- as.factor(depart_arrivee$Position_Start)
depart_arrivee$Classement_final <- factor(depart_arrivee$Classement_final, levels = niveaux_ordre)
data_final$Position_Start <- as.numeric(data_final$Position_Start)
data_final$Classement_final <- as.numeric(data_final$Classement_final)
data_final$Position_Start <- as.factor(data_final$Position_Start)
data_final$Classement_final <- factor(data_final$Classement_final, levels = niveaux_ordre)
tableau_contingence <- table(data_final$Position_Start, data_final$Classement_final)
# Calculer les pourcentages par ligne
pourcentages <- prop.table(tableau_contingence, margin = 1) * 100
pourcentages <- round(pourcentages, 2)
pourcentages
# Tableau de contingence
tableau_contingence <- table(depart_arrivee$Position_Start, depart_arrivee$Classement_final)
# Calculer les pourcentages par ligne
pourcentages <- prop.table(tableau_contingence, margin = 1) * 100
pourcentages <- round(pourcentages, 2)
tableau_contingence <- table(data_final$Position_Start, data_final$Classement_final)
# Calculer les pourcentages par ligne
pourcentages2 <- prop.table(tableau_contingence, margin = 1) * 100
pourcentages2 <- round(pourcentages, 2)
pourcentages
pourcentages2
library(dplyr)
data$Position_Start[data$Position_Start == -1] <- NA
# Sélectionner les lignes sans NA dans la colonne spécifiée
data <- data[complete.cases(data$Position_Start) & !grepl("DNS|DNF", data$Temps_Final), ]
data_final <- data |> filter(Manche == 'Demi-final' |
Manche == 'Final' |
Manche == 'Quart-final')
depart_arrivee <- data[c("Position_Start", "Classement_final")]
data_final <- data_final[c("Position_Start", "Classement_final")]
niveaux_ordre <- as.character(1:8)
depart_arrivee$Position_Start <- as.numeric(depart_arrivee$Position_Start)
depart_arrivee$Classement_final <- as.numeric(depart_arrivee$Classement_final)
depart_arrivee$Position_Start <- as.factor(depart_arrivee$Position_Start)
depart_arrivee$Classement_final <- factor(depart_arrivee$Classement_final, levels = niveaux_ordre)
data_final$Position_Start <- as.numeric(data_final$Position_Start)
data_final$Classement_final <- as.numeric(data_final$Classement_final)
data_final$Position_Start <- as.factor(data_final$Position_Start)
data_final$Classement_final <- factor(data_final$Classement_final, levels = niveaux_ordre)
# Tableau de contingence
tableau_contingence <- table(depart_arrivee$Position_Start, depart_arrivee$Classement_final)
# Calculer les pourcentages par ligne
pourcentages <- prop.table(tableau_contingence, margin = 1) * 100
pourcentages <- round(pourcentages, 2)
tableau_contingence2 <- table(data_final$Position_Start, data_final$Classement_final)
# Calculer les pourcentages par ligne
pourcentages2 <- prop.table(tableau_contingence2, margin = 1) * 100
pourcentages2 <- round(pourcentages, 2)
pourcentages
pourcentages2
tableau_contingence2 <- table(data_final$Position_Start, data_final$Classement_final)
# Calculer les pourcentages par ligne
pourcentages2 <- prop.table(tableau_contingence2, margin = 1) * 100
pourcentages2 <- round(pourcentages, 2)
tableau_contingence2 <- table(data_final$Position_Start, data_final$Classement_final)
# Calculer les pourcentages par ligne
pourcentages2 <- prop.table(tableau_contingence2, margin = 1) * 100
pourcentages2 <- round(pourcentages2, 2)
pourcentages
pourcentages2
difference <- pourcentages2 - pourcentages
difference <- pourcentages2 - pourcentages
difference
2948/8
esquisse:::esquisser()
View(data)
View(data_final)
knitr::opts_chunk$set(echo = TRUE)
# Charger les packages
library(tidymodels)
# Charger les données (remplacez "votre_dataset.csv" par le nom de votre fichier de données)
# Spécifier les colonnes prédictives et la colonne de la variable dépendante
predictors <- c("Position_Start", "Rang_T1", "Rang_T2", "Rang_T3", "Rang_T4")  # Remplacez par vos noms de variables prédictives
response <- "Classement_final"  # Remplacez par le nom de votre variable dépendante
# # Diviser les données en ensembles d'entraînement et de test
# set.seed(123)  # Pour la reproductibilité
# split <- initial_split(data, prop = 0.7, strata = response)
# train_data <- training(split)
# test_data <- testing(split)
#
# # Prétraitement des données
# # (Cela dépendra de la nature de vos données et des transformations nécessaires)
# preprocess <- recipe(formula = as.formula(paste(response, "~", paste(predictors, collapse = "+"))), data = train_data) %>%
#   step_...  # Ajoutez les étapes de prétraitement nécessaires (ex. imputation, transformation, etc.)
#
# # Définir le modèle de régression logistique
# logistic_model <- logistic_reg() %>%
#   set_engine("glm")  # Vous pouvez également utiliser "glmnet" pour la régularisation L1/L2
#
# # Créer le workflow avec les étapes de prétraitement et le modèle
# workflow <- workflow() %>%
#   add_recipe(preprocess) %>%
#   add_model(logistic_model)
#
# # Entraîner le modèle
# trained_model <- fit(workflow, data = train_data)
#
# # Faire des prédictions sur l'ensemble de test
# predictions <- predict(trained_model, new_data = test_data)
#
# # Évaluer les performances du modèle
# conf_mat <- conf_mat(predictions, truth = !!sym(response), estimate = !!sym("`.pred_class`"))
# print(conf_mat)
# Charger les packages
library(tidymodels)
# Charger les données (remplacez "votre_dataset.csv" par le nom de votre fichier de données)
# Spécifier les colonnes prédictives et la colonne de la variable dépendante
predictors <- c("Position_Start", "Rang_T1", "Rang_T2", "Rang_T3", "Rang_T4")  # Remplacez par vos noms de variables prédictives
response <- "Classement_final"  # Remplacez par le nom de votre variable dépendante
# # Diviser les données en ensembles d'entraînement et de test
set.seed(123)  # Pour la reproductibilité
split <- initial_split(data, prop = 0.7, strata = response)
train_data <- training(split)
test_data <- testing(split)
#
# # Prétraitement des données
# # (Cela dépendra de la nature de vos données et des transformations nécessaires)
# preprocess <- recipe(formula = as.formula(paste(response, "~", paste(predictors, collapse = "+"))), data = train_data) %>%
#   step_...  # Ajoutez les étapes de prétraitement nécessaires (ex. imputation, transformation, etc.)
#
# # Définir le modèle de régression logistique
# logistic_model <- logistic_reg() %>%
#   set_engine("glm")  # Vous pouvez également utiliser "glmnet" pour la régularisation L1/L2
#
# # Créer le workflow avec les étapes de prétraitement et le modèle
# workflow <- workflow() %>%
#   add_recipe(preprocess) %>%
#   add_model(logistic_model)
#
# # Entraîner le modèle
# trained_model <- fit(workflow, data = train_data)
#
# # Faire des prédictions sur l'ensemble de test
# predictions <- predict(trained_model, new_data = test_data)
#
# # Évaluer les performances du modèle
# conf_mat <- conf_mat(predictions, truth = !!sym(response), estimate = !!sym("`.pred_class`"))
# print(conf_mat)
# Charger les packages
library(tidymodels)
# Charger les données (remplacez "votre_dataset.csv" par le nom de votre fichier de données)
# Spécifier les colonnes prédictives et la colonne de la variable dépendante
predictors <- c("Position_Start", "Rang_T1", "Rang_T2", "Rang_T3", "Rang_T4")  # Remplacez par vos noms de variables prédictives
response <- "Classement_final"  # Remplacez par le nom de votre variable dépendante
# # Diviser les données en ensembles d'entraînement et de test
set.seed(123)  # Pour la reproductibilité
split <- initial_split(data, prop = 0.7, strata = response)
train_data <- training(split)
test_data <- testing(split)
# Prétraitement des données
# (Cela dépendra de la nature de vos données et des transformations nécessaires)
preprocess <- recipe(formula = as.formula(paste(response, "~", paste(predictors, collapse = "+"))), data = train_data)
# Définir le modèle de régression logistique
logistic_model <- logistic_reg() %>%
set_engine("glm")  # Vous pouvez également utiliser "glmnet" pour la régularisation L1/L2
# Créer le workflow avec les étapes de prétraitement et le modèle
workflow <- workflow() %>%
add_recipe(preprocess) %>%
add_model(logistic_model)
# Entraîner le modèle
trained_model <- fit(workflow, data = train_data)
# Faire des prédictions sur l'ensemble de test
predictions <- predict(trained_model, new_data = test_data)
# Évaluer les performances du modèle
conf_mat <- conf_mat(predictions, truth = !!sym(response), estimate = !!sym("`.pred_class`"))
install.packages("dotwhisker")
# Spécifier les colonnes prédictives et la colonne de la variable dépendante
predictors <- c("Position_Start", "Rang_T1", "Rang_T2", "Rang_T3", "Rang_T4")  # Remplacez par vos noms de variables prédictives
class(data$Classement_final)
library(dplyr)
data$Position_Start[data$Position_Start == -1] <- NA
# Sélectionner les lignes sans NA dans la colonne spécifiée
data <- data[complete.cases(data$Position_Start) & !grepl("DNS|DNF", data$Temps_Final), ]
data_final <- data |> filter(Manche == 'Demi-final' |
Manche == 'Final' |
Manche == 'Quart-final')
depart_arrivee <- data[c("Position_Start", "Classement_final")]
data_final <- data_final[c("Position_Start", "Classement_final")]
niveaux_ordre <- as.character(1:8)
depart_arrivee$Position_Start <- as.numeric(depart_arrivee$Position_Start)
depart_arrivee$Classement_final <- as.numeric(depart_arrivee$Classement_final)
depart_arrivee$Position_Start <- as.factor(depart_arrivee$Position_Start)
depart_arrivee$Classement_final <- factor(depart_arrivee$Classement_final, levels = niveaux_ordre)
data_final$Position_Start <- as.numeric(data_final$Position_Start)
data_final$Classement_final <- as.numeric(data_final$Classement_final)
data_final$Position_Start <- as.factor(data_final$Position_Start)
data_final$Classement_final <- factor(data_final$Classement_final, levels = niveaux_ordre)
# Tableau de contingence
tableau_contingence <- table(depart_arrivee$Position_Start, depart_arrivee$Classement_final)
# Calculer les pourcentages par ligne
pourcentages <- prop.table(tableau_contingence, margin = 1) * 100
pourcentages <- round(pourcentages, 2)
tableau_contingence2 <- table(data_final$Position_Start, data_final$Classement_final)
# Calculer les pourcentages par ligne
pourcentages2 <- prop.table(tableau_contingence2, margin = 1) * 100
pourcentages2 <- round(pourcentages2, 2)
difference <- pourcentages2 - pourcentages
class(data$Classement_final)
# Charger les packages
library(tidymodels)
library(dotwhisker)  # for visualizing regression results
# Charger les données (remplacez "votre_dataset.csv" par le nom de votre fichier de données)
# Spécifier les colonnes prédictives et la colonne de la variable dépendante
predictors <- c("Position_Start", "Rang_T1", "Rang_T2", "Rang_T3", "Rang_T4")  # Remplacez par vos noms de variables prédictives
response <- "Classement_final"  # Remplacez par le nom de votre variable dépendante
# # Diviser les données en ensembles d'entraînement et de test
set.seed(123)  # Pour la reproductibilité
split <- initial_split(data, prop = 0.7, strata = response)
train_data <- training(split)
test_data <- testing(split)
# Prétraitement des données
# (Cela dépendra de la nature de vos données et des transformations nécessaires)
preprocess <- recipe(formula = as.formula(paste(response, "~", paste(predictors, collapse = "+"))), data = train_data)
# Définir le modèle de régression logistique
logistic_model <- ordinal_reg() %>%
set_engine("clm")
??ordinal_reg
# Charger les packages
library(tidymodels)
library(dotwhisker)  # for visualizing regression results
data[, c("Classement_final", "Position_Start", "Rang_T1", "Rang_T2", "Rang_T3")] <- lapply(data[, c("Classement_final", "Position_Start", "Rang_T1", "Rang_T2", "Rang_T3")], as.numeric)
data[, c("Classement_final", "Position_Start", "Rang_T1", "Rang_T2", "Rang_T3")] <- lapply(data[, c("Classement_final", "Position_Start", "Rang_T1", "Rang_T2", "Rang_T3")], function(x) factor(x, levels = 1:8, ordered = TRUE))
# Charger les données (remplacez "votre_dataset.csv" par le nom de votre fichier de données)
# Spécifier les colonnes prédictives et la colonne de la variable dépendante
predictors <- c("Position_Start", "Rang_T1", "Rang_T2", "Rang_T3", "Rang_T4")  # Remplacez par vos noms de variables prédictives
response <- "Classement_final"  # Remplacez par le nom de votre variable dépendante
# # Diviser les données en ensembles d'entraînement et de test
set.seed(123)  # Pour la reproductibilité
split <- initial_split(data, prop = 0.7, strata = response)
train_data <- training(split)
test_data <- testing(split)
# Prétraitement des données
# (Cela dépendra de la nature de vos données et des transformations nécessaires)
preprocess <- recipe(formula = as.formula(paste(response, "~", paste(predictors, collapse = "+"))), data = train_data)
# Définir le modèle de régression logistique
logistic_model <- ordinal_reg() %>%
set_engine("clm")
# Charger les packages
library(tidymodels)
library(dotwhisker)  # for visualizing regression results
library(ordinal)
data[, c("Classement_final", "Position_Start", "Rang_T1", "Rang_T2", "Rang_T3")] <- lapply(data[, c("Classement_final", "Position_Start", "Rang_T1", "Rang_T2", "Rang_T3")], as.numeric)
data[, c("Classement_final", "Position_Start", "Rang_T1", "Rang_T2", "Rang_T3")] <- lapply(data[, c("Classement_final", "Position_Start", "Rang_T1", "Rang_T2", "Rang_T3")], function(x) factor(x, levels = 1:8, ordered = TRUE))
# Charger les données (remplacez "votre_dataset.csv" par le nom de votre fichier de données)
# Spécifier les colonnes prédictives et la colonne de la variable dépendante
predictors <- c("Position_Start", "Rang_T1", "Rang_T2", "Rang_T3", "Rang_T4")  # Remplacez par vos noms de variables prédictives
response <- "Classement_final"  # Remplacez par le nom de votre variable dépendante
# # Diviser les données en ensembles d'entraînement et de test
set.seed(123)  # Pour la reproductibilité
split <- initial_split(data, prop = 0.7, strata = response)
train_data <- training(split)
test_data <- testing(split)
# Prétraitement des données
# (Cela dépendra de la nature de vos données et des transformations nécessaires)
preprocess <- recipe(formula = as.formula(paste(response, "~", paste(predictors, collapse = "+"))), data = train_data)
# Définir le modèle de régression logistique
logistic_model <- ordinal_reg() %>%
set_engine("clm")
data <- read.csv("./data/final_dataset.csv")
View(data)
data_2000_2018 <- read.csv("./data/final_dataset.csv")
data_2000_2018 <- read.csv("./data/Datasets/final_dataset.csv")
data_2018_2019 <- read.csv("./data/Datasets/2018-19.csv")
data_2019_2020 <- read.csv("./data/Datasets/2019-20.csv")
data_2020_2021 <- read.csv("./data/2020-2021.csv")
data_2021_2022 <- read.csv("./data/2021-2022.csv")
View(data_2018_2019)
View(data_2021_2022)
data_2000_2018 <- read.csv("./data/Datasets/final_dataset.csv")
data_2018_2019 <- read.csv("./data/Datasets/2018-19.csv")
data_2019_2020 <- read.csv("./data/Datasets/2019-20.csv")
data_2020_2021 <- read.csv("./data/2020-2021.csv")
data_2021_2022 <- read.csv("./data/2021-2022.csv")
classement <- read.csv("./data/Datasets/EPLStandings.csv")
View(classement)
View(classement)
install.packages("reshape")
library(reshape2)
Classement_vrai <- melt(classement, id.vars = "Team", variable.name = "X", value.name = "Resultat")
View(Classement_vrai)
Classement_vrai <- melt(classement, id.vars = "Equipe", variable.name = "Annee", value.name = "Resultat")
Classement_vrai <- melt(classement, id.vars = "Team", variable.name = "X", value.name = "Resultat")
data_2000_2018 <- read.csv("./data/Datasets/final_dataset.csv")
data_2018_2019 <- read.csv("./data/Datasets/2018-19.csv")
data_2019_2020 <- read.csv("./data/Datasets/2019-20.csv")
data_2020_2021 <- read.csv("./data/2020-2021.csv")
data_2021_2022 <- read.csv("./data/2021-2022.csv")
classement_ini <- read.csv("./data/Datasets/EPLStandings.csv")
library(reshape2)
Classement <- melt(classement_ini, id.vars = "Team", variable.name = "X", value.name = "Resultat")
Classement <- rename(Classement, Team = "Equipe", X = "Annee")
Classement <- melt(classement_ini, id.vars = "Team", variable.name = "X", value.name = "Resultat")
Classement <- rename(Classement, Team = "Equipe", X = "Annee", Resultat = "Resultat")
Classement <- melt(classement_ini, id.vars = "Team", variable.name = "X", value.name = "Resultat")
colnames(Classement) <- c("Equipe","Annee","Resultat")
View(Classement)
#Réorganiser les données
Classement <- melt(classement_ini, id.vars = "Team", variable.name = "X", value.name = "Resultat")
#Renommez les colonnes
colnames(Classement) <- c("Equipe","Annee","Resultat")
# Supprimer le "X" de la colonne "Annee"
Classement$Annee <- sub("X", "", Classement$Annee)
library(reshape2)
library(ggplot2)
#Réorganiser les données
Classement <- melt(classement_ini, id.vars = "Team", variable.name = "X", value.name = "Resultat")
#Renommez les colonnes
colnames(Classement) <- c("Equipe","Annee","Resultat")
# Supprimer le "X" de la colonne "Annee"
Classement$Annee <- as.numeric(sub("X", "", Classement$Annee))
ggplot(df_transformed, aes(x = Annee, y = Resultat, color = Equipe)) +
geom_line() +
geom_point() +
scale_y_reverse() +  # Inverser l'axe y pour avoir 1 en haut et 20 en bas
labs(title = "Classement des équipes par année",
x = "Année",
y = "Classement") +
theme_minimal()
ggplot(Classement, aes(x = Annee, y = Resultat, color = Equipe)) +
geom_line() +
geom_point() +
scale_y_reverse() +  # Inverser l'axe y pour avoir 1 en haut et 20 en bas
labs(title = "Classement des équipes par année",
x = "Année",
y = "Classement") +
theme_minimal()
library(reshape2)
library(ggplot2)
library(plotly)
plot_ly(data = df_transformed, x = ~Annee, y = ~Resultat, color = ~Equipe, type = 'scatter', mode = 'lines+markers') %>%
layout(title = "Classement des équipes par année",
xaxis = list(title = "Année"),
yaxis = list(title = "Classement"),
showlegend = TRUE) %>%
config(displayModeBar = FALSE)  # Désactiver la barre d'options interactive (facultatif)
plot_ly(data = classement, x = ~Annee, y = ~Resultat, color = ~Equipe, type = 'scatter', mode = 'lines+markers') %>%
layout(title = "Classement des équipes par année",
xaxis = list(title = "Année"),
yaxis = list(title = "Classement"),
showlegend = TRUE) %>%
config(displayModeBar = FALSE)  # Désactiver la barre d'options interactive (facultatif)
plot_ly(data = Classement, x = ~Annee, y = ~Resultat, color = ~Equipe, type = 'scatter', mode = 'lines+markers') %>%
layout(title = "Classement des équipes par année",
xaxis = list(title = "Année"),
yaxis = list(title = "Classement"),
showlegend = TRUE) %>%
config(displayModeBar = FALSE)  # Désactiver la barre d'options interactive (facultatif)
plot_ly(data = Classement, x = ~Annee, y = ~Resultat, color = ~Equipe, type = 'scatter', mode = 'lines+markers') %>%
layout(title = "Classement des équipes par année",
xaxis = list(title = "Année"),
yaxis = list(title = "Classement"),
showlegend = TRUE,
legend = list(traceorder = 'normal')) %>%
config(displayModeBar = FALSE)  # Désactiver la barre d'options interactive (facultatif)
plot_ly(data = Classement, x = ~Annee, y = ~Resultat, color = ~Equipe, type = 'scatter', mode = 'lines+markers') %>%
layout(title = "Classement des équipes par année",
xaxis = list(title = "Année"),
yaxis = list(title = "Classement"),
showlegend = TRUE,
legend = list(traceorder = 'normal')) %>%
config(displayModeBar = FALSE)  # Désactiver la barre d'options interactive (facultatif)
plot_ly() %>%
add_trace(type = 'scatter', mode = 'none', showlegend = FALSE, hoverinfo = 'none') %>%
add_trace(data = df_transformed, x = ~Annee, y = ~Resultat, color = ~Equipe, type = 'scatter', mode = 'lines+markers') %>%
layout(title = "Classement des équipes par année",
xaxis = list(title = "Année"),
yaxis = list(title = "Classement"),
legend = list(traceorder = 'normal')) %>%
config(displayModeBar = FALSE)  # Désactiver la barre d'options interactive (facultatif)
plot_ly() %>%
add_trace(type = 'scatter', mode = 'none', showlegend = FALSE, hoverinfo = 'none') %>%
add_trace(data = Classement, x = ~Annee, y = ~Resultat, color = ~Equipe, type = 'scatter', mode = 'lines+markers') %>%
layout(title = "Classement des équipes par année",
xaxis = list(title = "Année"),
yaxis = list(title = "Classement"),
legend = list(traceorder = 'normal')) %>%
config(displayModeBar = FALSE)  # Désactiver la barre d'options interactive (facultatif)
plot_ly(data = Classement, x = ~Annee, y = ~Resultat, color = ~Equipe, type = 'scatter', mode = 'lines+markers') %>%
layout(title = "Classement des équipes par année",
xaxis = list(title = "Année"),
yaxis = list(title = "Classement"),
showlegend = TRUE,
legend = list(traceorder = 'normal')) %>%
config(displayModeBar = FALSE)  # Désactiver la barre d'options interactive (facultatif)
plot_ly(data = df_transformed, x = ~Annee, y = ~Resultat, color = ~Equipe, type = 'scatter', mode = 'lines+markers',
legendgroup = ~Equipe) %>%
layout(title = "Classement des équipes par année",
xaxis = list(title = "Année"),
yaxis = list(title = "Classement"),
showlegend = TRUE) %>%
config(displayModeBar = FALSE)
plot_ly(data = Classement, x = ~Annee, y = ~Resultat, color = ~Equipe, type = 'scatter', mode = 'lines+markers',
legendgroup = ~Equipe) %>%
layout(title = "Classement des équipes par année",
xaxis = list(title = "Année"),
yaxis = list(title = "Classement"),
showlegend = TRUE) %>%
config(displayModeBar = FALSE)
plot_ly(data = Classement, x = ~Annee, y = ~Resultat, color = ~Equipe, type = 'scatter', mode = 'lines+markers',
legendgroup = ~Equipe) %>%
layout(title = "Classement des équipes par année",
xaxis = list(title = "Année"),
yaxis = list(title = "Classement"),
showlegend = TRUE) %>%
scale_y_reverse() |>  # Inverser l'axe y pour avoir 1 en haut et 20 en bas
config(displayModeBar = FALSE)
plot_ly(data = Classement, x = ~Annee, y = ~Resultat, color = ~Equipe, type = 'scatter', mode = 'lines+markers',
legendgroup = ~Equipe) %>%
layout(title = "Classement des équipes par année",
xaxis = list(title = "Année"),
yaxis = list(title = "Classement"),
showlegend = TRUE) %>%
scale_y_reverse() %>%
config(displayModeBar = FALSE)
plot_ly(data = Classement, x = ~Annee, y = ~Resultat, color = ~Equipe, type = 'scatter', mode = 'lines+markers',
legendgroup = ~Equipe) %>%
layout(title = "Classement des équipes par année",
xaxis = list(title = "Année"),
yaxis = list(title = "Classement", autorange = "reversed"),  # Inverser l'axe y
showlegend = TRUE) %>%
config(displayModeBar = FALSE)
library(reshape2)
library(ggplot2)
library(plotly)
library(dplyr)
stat <- full_join(data_2000_2018, data_2018_2019) |>
full_join(., data_2020_2021) |> full_join(., data_2019_2020) |> full_join(., data_2021_2022)
result <- Reduce(full_join, list(data_2000_2018, data_2018_2019, data_2019_2020,data_2020_2021, data_2021_2022))
View(result)
write.csv(result, "data/fichier_globale.csv", row.names = TRUE)
library(reshape2)
library(ggplot2)
library(plotly)
library(dplyr)
Dataset_stat <- read.csv('./data/fichier_globale.csv')
classement_ini <- read.csv("./data/Datasets/EPLStandings.csv")
library(reshape2)
library(ggplot2)
library(plotly)
library(dplyr)
Dataset_stat <- read.csv('./data/fichier_globale.csv')
classement_ini <- read.csv("./data/EPLStandings.csv")
View(Dataset_stat)
library(reshape2)
library(ggplot2)
library(plotly)
library(dplyr)
Dataset_stat <- read.csv('./data/fichier_globale.csv')
classement_ini <- read.csv("./data/EPLStandings.csv")
View(Dataset_stat)
Dataset_stat <- read.csv('./data/fichier_globale.csv', sep = ";")
classement_ini <- read.csv("./data/EPLStandings.csv")
View(Dataset_stat)
